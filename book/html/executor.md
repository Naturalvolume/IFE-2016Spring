# 浏览器执行js的过程
js编译器的基本工作流程包括：解析、解释、优化（与css编译器的解析、转换、代码生成不同）。

### 步骤一：解析
解析步骤又可以拆分成两个小步骤：
```javascript
// 如一段代码
var name = 'web'
console.log(name)
```

- 词法分析：将js代码解析成一个个的令牌(`token`)。

通过词法分析将代码逐个字符进行解析，生成类似下面结构的令牌，令牌类型包括：关键字、标识符、符号、字符串。

```javascript
Keyword(var)
Identifier(name)
Punctuator(=)
String('web')
Identifier(console)
Punctuator(.)
Identifier(log)
Punctuator(()
Identifier(name)
Punctuator())
```

- 语法分析：将令牌组装成一棵抽象语法树(`AST`)，生成树的过程并不是简单的添加所有令牌，而是去除不必要的符号令牌后，按照语法规则来生成。

### 步骤二：解释
js引擎通过解释器`lgnition`将AST转换成字节码。字节码是对机器码的一个抽象描述，相对于机器码，代码量更小，可减少内存消耗。

转换成如下所示的字节码（语法已非常接近汇编）
```javascript
[generated bytecode for function: log (0x1e680d83fc59 <SharedFunctionInfo log>)]
Parameter count 1
Register count 6
Frame size 48
 9646 E> 0x376a94a60ea6 @    0 : a7                StackCheck 
         ......
         0x376a94a60ec9 @   35 : 26 f6             Star r5
 9683 E> 0x376a94a60ecb @   37 : 5a f9 02 f7 f6 06 CallProperty2 r2, <this>, r4, r5, [6]
         0x376a94a60ed1 @   43 : 0d                LdaUndefined 
 9729 S> 0x376a94a60ed2 @   44 : ab                Return 
Constant pool (size = 3)
Handler Table (size = 0)
Source Position Table (size = 24)
```

### 步骤三：优化
解释器在对AST进行解释和执行时，会将一些重复可优化的操作（如类型判断）收集起来生成分析数据，然后将生成的字节码和分析数据传给编译器`TurboFan`，编译器会根据分析数据来生成高度优化的机器码。

优化后的机器码的作用和缓存类似，当解释器再次遇到相同的内容时，可直接执行优化后的机器码。

但是优化后的代码有时可能会无法运行（比如函数参数类型改变），那么会再次反优化为字节码交给解释器。

### 函数调用过程中的内存管理
解释器创建了**调用栈**记录函数的调用流程。每调用一个函数，解释器就会把该函数添加进调用栈，然后为被添加进的函数创建一个**栈帧**（用来保存函数的局部变量以及执行语句）并立即执行。若正在执行的函数还调用了其它函数，那么新函数也会被添加进调用栈并执行。一旦这个函数执行结束，对应的栈帧也会被立即销毁。

查看调用栈的两种方式：
- 调用函数`console.trace()`打印到控制台
- 利用浏览器开发者工具进行断点调试

函数调用栈的缺点：
- 栈虽然只会在使用时创建，结束时销毁，但不能无限增长。当分配的调用栈空间被占满时，就会发生“栈溢出”错误。