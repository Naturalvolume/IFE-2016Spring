# 垃圾回收机制
V8的内存只有1.4G(64位)和0.7G(32位)，限制堆的大小，主要是因为 (1)网页用不了那么多数据; (2)一次垃圾回收需要50ms以上。

垃圾回收分为 手动回收 和 自动回收
**手动回收**：何时分配内存、销毁内存都是代码控制的
**自动回收**：由垃圾回收器释放，并不需要手动通过代码释放

### 调用栈中的数据回收
js引擎通过向下移动 ESP(记录当前执行状态的指针) 销毁函数保存在栈中的执行上下文。
### 堆中的垃圾回收——新生代
**存储对象**：存时间短的

**容量**：8M(32位)、16M(64位)

**回收器**：副垃圾回收器

**回收算法**：Scavenge算法，把新生代区域一分为二，From中是正在使用中的对象，To空间处于空闲状态，回收过程为
- 在From空间分配对象，对象区域快被写满时，进行垃圾清理操作
- 垃圾回收时先对垃圾做标记
- 进入垃圾清理阶段，副垃圾回收器把存活的对象复制到空闲区域中，同时进行有序排列，所以这个复制过程也就完成了内存整理操作，空闲区域就没有内存碎片了
- 复制完成后，From 和 To进行翻转换位，即From变成To，To变成From，这就完成了垃圾对象的回收操作

**对象晋升策略**：目的是将存活时间长的对象转移到老生代中，晋升条件有两个(1)对象是否经历过Scavenge回收; (2)To空间的内存占用比是否超过限制(25%)

### 堆中的数据回收——老生代
**存储对象**：存时间长的

**回收器**：主垃圾回收器

**回收算法**：标记-清除(Mark-Sweep)、标记-整理(Mark-Compact)
- 标记-清除：标记阶段 标记活着的对象，清除阶段 清除没有被标记的对象
- 标记-整理：目的是改变经过一次清除后空间处于不连续状态的现象，过程是在对象被标记为死亡后，整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存

在V8中标记-清除 和 标记-整理配合使用，主要使用Mark-Sweep(速度快)，空间不足时使用Mark-Compact。

### 增量标记
**全停顿**：js运行在主线程上，执行垃圾回收算法会将正在执行的js脚本暂停下来，垃圾回收完毕后再恢复脚本执行

**增量标记**：为了降低老生代垃圾回收造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和js应用逻辑交替进行，直到标记阶段完成

# 内存泄露
### 发生原因
不再用到的内存，没有及时释放，就叫内存泄露。
- 缓存
- 计时器中引用未清除

```javascript
var someData = getData();
setInterval(function() {    
  var node = document.getElementById('Node');    
  if(node) {
    node.innerHTML = JSON.stringify(someData));
  }
}, 1000);
```

若node节点被删除，这里已经取不到了，但是还是有回调函数，无法被回收
- 意外的全局变量
- 闭包
- 事件监听

### 避免内存泄露
- 少用全局变量，避免意外产生全局变量
- 使用闭包时，当有dom元素的引用要及时清理
- 计时器中的回调没用时及时销毁
- 使用 WeakSet 和 WeakMap，它们对值对引用不计入垃圾回收机制，是弱引用