# 浏览器
### 单进程浏览器
指浏览器的所有功能模块都运行在同一个进程里，这些模块包含了 网络、插件、js运行环境、渲染引擎和页面等。

单进程浏览器的**缺点**：
- 不稳定：可以用插件实现诸如web视频、web游戏等各种强大的功能，但是插件最容易出问题，所以插件的意外崩溃会引起整个浏览器的崩溃
- 不流畅：所有页面的渲染模块、js执行环境以及插件都运行在同一个线程中，意味着同一时刻只能有一个模块可以执行
- 不安全：通过插件可以获取到操作系统的任意资源，所以当运行一个插件时也就意味着插件可以操作电脑，若是个恶意插件，那就会释放病毒、窃取账号密码，引发安全性问题。

所以单浏览器会出现这样的场景：当用浏览器打开多个页面时，突然某个页面崩溃了或者失去响应，那么可能整个浏览器都会崩溃或者无响应。
### chrome 打开一个页面需要启动多少进程？
chrome 是第一个采取多进程架构的浏览器，浏览器需要一边渲染页面一边请求后端数据同时还要响应用户事件，使用进程可以避免多个进程同时操作同一份数据产生的冲突问题（不同进程间的资源是独享的，不可互相访问）。

> 多线程更轻量，多进程更安全更稳定。

- 浏览器的主进程：负责界面显示（地址栏、导航栏、书签等）、处理用户事件、子进程管理、下载资源、管理IPC，同时提供存储等功能；
- 渲染进程：每个**tab标签**都会创建一个渲染进程。将html、css、js转换为**用户可以交互的网页**，**排版引擎**和**js v8引擎**都在渲染进程中，处于安全考虑，渲染进程都运行在**沙箱模式**下（不能读写硬盘上的数据、不能获取操作系统权限）；
> 保障了渲染进程的稳定性，若某个标签页失去响应，用户可以关掉这个标签页，此时其它标签页依然运行着，可以正常使用。
- gpu进程：处理来自其它进程的gpu任务，比如来自渲染进程或扩展进程的3D css效果、图层合成等，还可以利用gpu硬件加速渲染，包括canvas绘制、css3转换、css3变换、webGl等；
> dom元素使用了这些属性，gpu进程就会在合成层的时候对它进行单独处理，提升到一个独立的层进行绘制，避免重新布局和重新绘制。

- 网络进程：负责页面的网络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理；
- 多个插件进程

### 浏览器内核的多线程
浏览器内核就是浏览器渲染进程，从接收下载文件后再到呈现整个页面的过程，由浏览器渲染进程负责。浏览器内核是多线程的，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：
- GUI渲染线程：负责渲染浏览器界面 HTML 元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。
- 定时触发器线程：浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。
- 事件触发线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。
- 异步http请求线程：在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。
- JavaScript 引擎线程：Javascript 引擎，也可以称为JS内核，主要负责处理 Javascript 脚本程序，例如V8引擎。Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。

> 由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起， GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。

[浏览器是如何调度进程和线程的？](https://mp.weixin.qq.com/s/nVHLr9d5Qc83NPJ7lox1oQ)

##### 进程之间通过IPC机制进行通信
##### 多进程浏览器优点：
- 解决不稳定问题：进程相互隔离，一个页面或插件崩溃时，影响的仅仅是当前页面或者插件进程，不会影响到浏览器和其他页面
- 解决不流畅问题：js运行在渲染进程中，所以js只会阻塞当前渲染页面，不会影响浏览器和其他页面
- 解决内存泄露问题：关闭网页，整个渲染进程也会被关闭，该进程所占用的内存都会被系统回收，解决了浏览器页面内存泄露问题
- 沙箱机制：相当于给插件进程和渲染进程上了锁，沙箱里的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据

##### 多进程浏览器的缺点
- 更高的资源占用
- 更复杂的体系架构

**主动防御**：发现程序有可疑行为时立即拦截并终止运行
**沙盒技术原理**：发现可疑行为后让程序继续运行，只有发现的确是病毒时才会终止
**沙盒技术运行流程**：让疑似病毒文件的可疑行为在虚拟的沙盒中表演，沙盒会记下它的每一个动作，当疑似病毒充分暴露了病毒属性后，沙盒就会执行**回滚**机制，将病毒的痕迹和动作抹去，恢复系统到正常状态
[浏览器沙盒模型](https://www.cnblogs.com/slly/p/6639173.html)
[Chrome架构：仅仅打开了1个页面，为什么有4个进程？](https://cloud.tencent.com/developer/news/414508)
### 浏览器渲染过程
- 构建dom树：从**网络**或**硬盘**中获得html，将字节解析为文件指定编码字符，根据html规范将字符串转换成各种令牌标签（如html、body等），解析成一个树状对象模型（dom树）
- 样式计算：style标签内的css、内嵌的css、外链css
- 创建布局树：遍历dom树，将所有可见节点加入布局树，计算dom元素的布局信息
- 分层：渲染引擎为特定的节点（如3D变换、页面滚动、设置z-index的定位元素）生成专用的图层，并生成一棵对应的图层树
- 拆分绘制图层：把一个图层的绘制拆分成很多小的绘制指令，把指令按顺序组成一个待绘制列表，列表准备好之后，主线程将绘制列表提交给**合成线程**，合成线程**将图层划分为图块**
- 栅格化：按照视口附近的图块优先生成位图
- 显示：所有图块被栅格化后，合成线程生成绘制图块的命令，将该命令提交给浏览器进程，浏览器最后进行显示

### 会引起回流和重绘的操作
**回流**：
- 常见的几何属性改变：width、height、padding、margin、left、top、border等
- 获取一些需要**立刻计算得到的属性**：offsetTop、offsetLeft、offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight时，浏览器为了获取这些值，也会进行回流
- 调用 getComputedStyle 方法，或IE里的 currentStyle 时，也会触发回流（即时性、准确性）
- 添加或删除可见dom节点
- 浏览器窗口尺寸的变化（resize事件发生时）
- 填充内容的改变：如文本的改变或图片大小改变引起的计算值宽度和高度的改变

**优化一**：
- 浏览器自己的优化：维护一个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定数量 或 到了一定时间间隔，浏览器就`flush`队列，进行一个批处理，将多次回流、重绘变成一次。

**优化二**：
- 使用**类名合并**改变样式
- 提升为合成层，如使用`will-change`
  - 合成层的位图会交给gpu合成，比cpu处理要快
  - 只会repaint本身，不会影响到其它层
  - 对 transform 和 opacity，不会触发 layout 和 paint
- 将**需要多次重排的元素**，`position`属性设置为`absolute`或`fixed`，元素脱离了文档流，它的变化不会影响到其他元素
- 若需创建多个dom节点，可使用`DocumentFragment`创建完后一次性的加入`document`

浏览器使用**flush队列**，缓存触发的回流和重绘任务，待队列中任务多起来 或者 到了一定的时间间隔 或 不得已的时候将任务一口气出队，所以，当访问即时属性时，浏览器会为了获得此时此刻、最准确的属性值，将flush队列的任务出队。


